<html>
<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ol3/3.11.0-beta.2/ol.min.css" type="text/css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ol3/3.11.0-beta.2/ol-debug.js"></script>
  <style>
    body {background: #000;}
    #map {position:absolute;top:0;left:0;right:300px;bottom:0;cursor:pointer;}
    #layerList {position:absolute;top:5px;right:0;bottom:75%;width:290px;overflow:auto;}
    #layerList div {color:#ccc;cursor:pointer;}
    #layerList div.hidden {opacity:0.3;}
    #layerList div div {width:15px;height:15px;display:inline-block;}
    #tileInfo {position:absolute;top:25%;bottom:0;right:0;width:290px;overflow:auto;color:#fff;}
  </style>
</head>
<body>
<div id="map"></div>
<div id="layerList"></div>
<pre id="tileInfo"></pre>
<script>

var map = new ol.Map({
  layers: [
    new ol.layer.Tile({
      source: new ol.source.OSM(),
      opacity: 0.5
    })
  ],
  target: 'map',
  view: new ol.View({
    center: [0, 0],
    zoom: 0
  })
});

function generateColor(str) {
  var rgb = [0, 0, 0];
  for (var i = 0; i < str.length; i++) {
      var v = str.charCodeAt(i);
      rgb[v % 3] = (rgb[i % 3] + (13*(v%13))) % 12;
  }
  var r = 4 + rgb[0];
  var g = 4 + rgb[1];
  var b = 4 + rgb[2];
  r = (r * 16) + r;
  g = (g * 16) + g;
  b = (b * 16) + b;
  return [r,g,b,1];
};

var tileUrlFunction;
var tilegrid3857 = ol.tilegrid.createXYZ();

function initLayer(data) {
  var layer;
  var layerList = document.getElementById('layerList');
  var layerStyleMap = {}, layerStyleVisibility = {};
  data['vector_layers'].forEach(function(el) {
    var color = generateColor(el['id']);
    var style = new ol.style.Style({
      fill: new ol.style.Fill({color: color}),
      stroke: new ol.style.Stroke({color: color, width: 1})
    });
    layerStyleMap[el['id']] = style;
    layerStyleVisibility[el['id']] = true;

    var item = document.createElement('div');
    item.innerHTML = '<div style="' +
      'background:rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',1);' +
      '"></div> ' + el['id'];

    item.addEventListener('click', function(e) {
      layerStyleVisibility[el['id']] = !layerStyleVisibility[el['id']];
      item.className = layerStyleVisibility[el['id']] ? '' : 'hidden';
      layer.changed();
    });
    layerList.appendChild(item);
  });

  layer = new ol.layer.VectorTile({
    preload: Infinity,
    source: new ol.source.VectorTile({
      format: new ol.format.MVT(),
      tileGrid: new ol.tilegrid.createXYZ({
        minZoom: data['minzoom'],
        maxZoom: data['maxzoom']
      }),
      tilePixelRatio: 16,
      urls: data['tiles']
    }),
    //extent: ol.proj.transformExtent(data['bounds'], 'EPSG:4326', 'EPSG:3857'),
    style: function(feature, resolution) {
      var layerId = feature.get('layer');
      if (!layerStyleVisibility[layerId]) return null;
      var style = layerStyleMap[layerId];
      if (/_label$/.test(layerId) &&
          layerId != 'road_label' && layerId != 'waterway_label') {
        return [new ol.style.Style({
          text: new ol.style.Text({
            text: feature.get('name') || 'err',
            fill: style.getFill(),
            stroke: new ol.style.Stroke({color: 'rgba(0,0,0,0.8)', width: 1})
          })
        })];
      }
      return [style];
    }
  });

  tileUrlFunction = layer.getSource().getTileUrlFunction();

  var center = data['center'].split(',');
  map.getView().setCenter(ol.proj.fromLonLat(
    [parseFloat(center[0]), parseFloat(center[1])]));
  map.getView().setZoom(parseInt(center[2], 10));

  map.addLayer(layer);

  map.addLayer(new ol.layer.Tile({
      source: new ol.source.TileDebug({
        projection: 'EPSG:3857',
        tileGrid: tilegrid3857
      })
  }));
}

var tileInfo = document.getElementById('tileInfo');
map.on('click', function(e) {
  tileInfo.innerHTML = '...';

  var tilecoord = tilegrid3857.getTileCoordForCoordAndResolution(
    e.coordinate, map.getView().getResolution());

  var url = tileUrlFunction(tilecoord, 1, ol.proj.get('EPSG:3857'));

  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (xhttp.readyState == 4 && xhttp.status == 200) {
      var format = new ol.format.MVT();

      // this is why we need the debug version of ol3, the readFeatures is not exported to the api
      var features = format.readFeatures(xhttp.response);

      var layers = {};
      var layerFeatureCounts = {};
      var layerClasses = {};

      features.forEach(function(f) {
        var layer = f.get('layer');
        var cls = f.get('class');
        var type = f.get('type');

        if (!(layer in layers)) {
          layers[layer] = {};
          layerClasses[layer] = {};
          layerFeatureCounts[layer] = 0;
        }
        layerFeatureCounts[layer]++;

        var props = f.getProperties();
        for (var key in props) {
          if (key == 'layer' || key == 'class' || key == 'type') continue;
          layers[layer][key] = true;
        }

        if (cls) {
          if (!(cls in layerClasses[layer])) {
            layerClasses[layer][cls] = {};
          }
          if (type) {
            if (!(type in layerClasses[layer][cls])) {
              layerClasses[layer][cls][type] = true;
            }
          }
        }
      });

      tileInfo.innerHTML =
        'tile: ' + tilecoord[0] + '/' + (-tilecoord[2] - 1) + '/' + tilecoord[1] + '<br />' +
        'PBF size: ' + xhttp.response.byteLength + ' B (' + Math.round(xhttp.response.byteLength / 1024) + ' kB)<br />' +
        'features: ' + features.length + '<br />' +
        'layers: ' + Object.keys(layers).length + '<br /><br />';

      for (var layer in layers) {
        tileInfo.innerHTML += '#' + layer + ' (features: ' + layerFeatureCounts[layer] + ')<br />';
        for (var key in layers[layer]) {
          tileInfo.innerHTML += '    [' + key + ']<br />';
        }
        for (var cls in layerClasses[layer]) {
          tileInfo.innerHTML += '    ' + cls + '<br />';
          for (var type in layerClasses[layer][cls]) {
            tileInfo.innerHTML += '        ' + type + '<br />';
          }
        }
        if (Object.keys(layerClasses[layer]).length == 0) {
          tileInfo.innerHTML += '    no class<br />';
        }
      }
    }
  };
  xhttp.responseType = 'arraybuffer';
  xhttp.open("GET", url, true);
  xhttp.send();
});

var url = window.location.hash.substr(1) || 'http://tileserver.maptiler.com/zurich.json'
var script = document.createElement('script');
script.src = url + '?callback=initLayer'
document.getElementsByTagName('head')[0].appendChild(script);
</script>
</body>
</html>
